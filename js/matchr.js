// Generated by CoffeeScript 1.12.7

/*
00     00   0000000   000000000   0000000  000   000  00000000 
000   000  000   000     000     000       000   000  000   000
000000000  000000000     000     000       000000000  0000000  
000 0 000  000   000     000     000       000   000  000   000
000   000  000   000     000      0000000  000   000  000   000
 */

(function() {
  var _, config, dissect, empty, last, merge, ranges, ref, sortRanges, str;

  ref = require('./kxk'), empty = ref.empty, last = ref.last, str = ref.str, _ = ref._;

  config = function(patterns, flags) {
    var a, p, results;
    results = [];
    for (p in patterns) {
      a = patterns[p];
      results.push([new RegExp(p, flags), a]);
    }
    return results;
  };

  sortRanges = function(rgs) {
    return rgs.sort(function(a, b) {
      if (a.start === b.start) {
        return a.index - b.index;
      } else {
        return a.start - b.start;
      }
    });
  };

  ranges = function(regexes, text, flags) {
    var arg, gi, gs, i, j, k, l, match, r, ref1, ref2, reg, rgs, s, value;
    if (!_.isArray(regexes)) {
      if (_.isString(regexes)) {
        if (regexes.indexOf('|') >= 0) {
          regexes = (function() {
            var k, len, ref1, results;
            ref1 = regexes.split('|');
            results = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              r = ref1[k];
              results.push([new RegExp(r, flags), 'found']);
            }
            return results;
          })();
        } else {
          regexes = [[new RegExp(regexes, flags), 'found']];
        }
      } else {
        regexes = [[regexes, 'found']];
      }
    } else if (!_.isArray(regexes[0])) {
      regexes = [regexes];
    }
    rgs = [];
    if (text == null) {
      return rgs;
    }
    for (r = k = 0, ref1 = regexes.length; 0 <= ref1 ? k < ref1 : k > ref1; r = 0 <= ref1 ? ++k : --k) {
      reg = regexes[r][0];
      if ((reg == null) || (reg.exec == null)) {
        console.error('no reg?', regexes, text, flags);
        return rgs;
      }
      arg = regexes[r][1];
      i = 0;
      s = text;
      while (s.length) {
        match = reg.exec(s);
        if (match == null) {
          break;
        }
        if (match.length === 1) {
          if (match[0].length > 0) {
            rgs.push({
              start: match.index + i,
              match: match[0],
              value: arg,
              index: r
            });
          }
          i += match.index + Math.max(1, match[0].length);
          s = text.slice(i);
        } else {
          gs = 0;
          for (j = l = 0, ref2 = match.length - 2; 0 <= ref2 ? l <= ref2 : l >= ref2; j = 0 <= ref2 ? ++l : --l) {
            value = arg;
            if (_.isArray(value) && j < value.length) {
              value = value[j];
            } else if (_.isObject(value) && j < _.size(value)) {
              value = [_.keys(value)[j], value[_.keys(value)[j]]];
            }
            if (match[j + 1] == null) {
              break;
            }
            gi = match[0].slice(gs).indexOf(match[j + 1]);
            rgs.push({
              start: match.index + i + gs + gi,
              match: match[j + 1],
              value: value,
              index: r
            });
            gs += match[j + 1].length;
          }
          i += match.index + match[0].length;
          s = text.slice(i);
        }
      }
    }
    return sortRanges(rgs);
  };

  dissect = function(ranges, opt) {
    var c, d, di, dps, i, k, l, len, len1, len2, len3, len4, len5, m, n, o, p, pn, q, r, ref1, ref2, ref3, ref4, ref5, rg, ri, si, t, u;
    if (opt == null) {
      opt = {
        join: false
      };
    }
    if (!ranges.length) {
      return [];
    }
    di = [];
    for (k = 0, len = ranges.length; k < len; k++) {
      rg = ranges[k];
      di.push([rg.start, rg.index]);
      di.push([rg.start + rg.match.length, rg.index]);
    }
    di.sort(function(a, b) {
      if (a[0] === b[0]) {
        return a[1] - b[1];
      } else {
        return a[0] - b[0];
      }
    });
    d = [];
    si = -1;
    for (l = 0, len1 = di.length; l < len1; l++) {
      dps = di[l];
      if (dps[0] > si) {
        si = dps[0];
        d.push({
          start: si,
          cls: []
        });
      }
    }
    p = 0;
    for (ri = m = 0, ref1 = ranges.length; 0 <= ref1 ? m < ref1 : m > ref1; ri = 0 <= ref1 ? ++m : --m) {
      rg = ranges[ri];
      while (d[p].start < rg.start) {
        p += 1;
      }
      pn = p;
      while (d[pn].start < rg.start + rg.match.length) {
        if (rg.value != null) {
          if (rg.value.split == null) {
            ref2 = rg.value;
            for (n = 0, len2 = ref2.length; n < len2; n++) {
              r = ref2[n];
              if (r.split == null) {
                continue;
              }
              ref3 = r.split('.');
              for (o = 0, len3 = ref3.length; o < len3; o++) {
                c = ref3[o];
                if (d[pn].cls.indexOf(c) < 0) {
                  d[pn].cls.push(c);
                }
              }
            }
          } else {
            ref4 = rg.value.split('.');
            for (q = 0, len4 = ref4.length; q < len4; q++) {
              c = ref4[q];
              if (d[pn].cls.indexOf(c) < 0) {
                d[pn].cls.push(c);
              }
            }
          }
        }
        if (pn + 1 < d.length) {
          if (!d[pn].match) {
            d[pn].match = rg.match.substr(d[pn].start - rg.start, d[pn + 1].start - d[pn].start);
          }
          pn += 1;
        } else {
          if (!d[pn].match) {
            d[pn].match = rg.match.substr(d[pn].start - rg.start);
          }
          break;
        }
      }
    }
    d = d.filter(function(i) {
      var ref5;
      return (ref5 = i.match) != null ? ref5.trim().length : void 0;
    });
    for (t = 0, len5 = d.length; t < len5; t++) {
      i = d[t];
      i.clss = i.cls.join(' ');
      delete i.cls;
    }
    if (d.length > 1) {
      for (i = u = ref5 = d.length - 2; ref5 <= 0 ? u <= 0 : u >= 0; i = ref5 <= 0 ? ++u : --u) {
        if (d[i].start + d[i].match.length === d[i + 1].start) {
          if (d[i].clss === d[i + 1].clss) {
            d[i].match += d[i + 1].match;
            d.splice(i + 1, 1);
          }
        }
      }
    }
    return d;
  };

  merge = function(dssA, dssB) {
    var A, B, d, result;
    result = [];
    A = dssA.shift();
    B = dssB.shift();
    while (A && B) {
      if (A.start + A.match.length < B.start) {
        result.push(A);
        A = dssA.shift();
        continue;
      }
      if (B.start + B.match.length < A.start) {
        result.push(B);
        B = dssB.shift();
        continue;
      }
      if (A.start < B.start) {
        d = B.start - A.start;
        result.push({
          start: A.start,
          clss: A.clss,
          match: A.match.slice(0, d)
        });
        A.start += d;
        A.match = A.match.slice(d);
        continue;
      }
      if (B.start < A.start) {
        d = A.start - B.start;
        result.push({
          start: B.start,
          clss: B.clss,
          match: B.match.slice(0, d)
        });
        B.start += d;
        B.match = B.match.slice(d);
        continue;
      }
      if (A.start === B.start) {
        d = A.match.length - B.match.length;
        result.push({
          start: A.start,
          clss: A.clss + " " + B.clss,
          match: d >= 0 && B.match || A.match
        });
        if (d > 0) {
          A.match = A.match.slice(B.match.length);
          A.start += B.match.length;
          B = dssB.shift();
        } else if (d < 0) {
          B.match = B.match.slice(A.match.length);
          B.start += A.match.length;
          A = dssA.shift();
        } else {
          A = dssA.shift();
          B = dssB.shift();
        }
      }
    }
    if (B && !A) {
      result = result.concat([B], dssB);
    }
    if (A && !B) {
      result = result.concat([A], dssA);
    }
    return result;
  };

  module.exports = {
    config: config,
    ranges: ranges,
    dissect: dissect,
    sortRanges: sortRanges,
    merge: merge
  };

}).call(this);
