// Generated by CoffeeScript 1.12.7

/*
00000000  000  000      00000000  000      000   0000000  000000000  
000       000  000      000       000      000  000          000     
000000    000  000      0000000   000      000  0000000      000     
000       000  000      000       000      000       000     000     
000       000  0000000  00000000  0000000  000  0000000      000
 */

(function() {
  var _, fileList, fs, log, ref, slash,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('./kxk'), slash = ref.slash, fs = ref.fs, log = ref.log, _ = ref._;


  /*           
      opt:  
            ignoreHidden: true # skip files that starts with a dot
            logError:     true # print message to console.log if a path doesn't exits
            depth:        0    # recurse into subdirectories if > 0
            matchExt:     null # string or list of strings to match
   */

  fileList = function(paths, opt) {
    var childdirs, children, copt, d, err, f, files, filter, i, j, k, len, len1, len2, p, pos, ps, ref1, stat;
    if (opt == null) {
      opt = {};
    }
    if (opt.ignoreHidden == null) {
      opt.ignoreHidden = true;
    }
    if (opt.logError == null) {
      opt.logError = true;
    }
    files = [];
    if (_.isString(paths)) {
      paths = [paths];
    }
    filter = function(p) {
      var ref1;
      if (slash.base(p).toLowerCase() === 'ntuser') {
        return true;
      }
      if (opt.ignoreHidden && slash.file(p).startsWith('.')) {
        return true;
      } else if (opt.matchExt != null) {
        if (_.isString(opt.matchExt) && slash.ext(p) !== opt.matchExt) {
          return true;
        } else if (_.isArray(opt.matchExt) && (ref1 = slash.ext(p), indexOf.call(opt.matchExt, ref1) < 0)) {
          return true;
        }
      }
      return false;
    };
    for (i = 0, len = paths.length; i < len; i++) {
      p = paths[i];
      try {
        ref1 = slash.splitFilePos(p), p = ref1[0], pos = ref1[1];
        stat = fs.statSync(p);
        if (stat.isDirectory()) {
          children = fs.readdirSync(p);
          children = (function() {
            var j, len1, results;
            results = [];
            for (j = 0, len1 = children.length; j < len1; j++) {
              f = children[j];
              results.push(slash.join(p, f));
            }
            return results;
          })();
          childdirs = [];
          for (j = 0, len1 = children.length; j < len1; j++) {
            p = children[j];
            ps = fs.statSync(p);
            if (ps.isDirectory()) {
              childdirs.push(slash.normalize(p));
            } else if (ps.isFile()) {
              if (!filter(p)) {
                if (slash.isAbsolute(p)) {
                  files.push(slash.resolve(p));
                } else {
                  files.push(slash.normalize(p));
                }
              }
            }
          }
          if ((opt.depth != null) && _.isInteger(opt.depth) && opt.depth > 0) {
            copt = _.clone(opt);
            copt.depth -= 1;
            for (k = 0, len2 = childdirs.length; k < len2; k++) {
              d = childdirs[k];
              files = files.concat(fileList(d, copt));
            }
          }
        } else if (stat.isFile()) {
          if (filter(p)) {
            continue;
          }
          p = slash.joinFilePos(p, pos);
          files.push(p);
        }
      } catch (error) {
        err = error;
        if (opt.logError) {
          log("[ERROR] kxk.fileList: " + err);
          log("paths:", paths);
          log("opt:", opt);
        }
      }
    }
    return files;
  };

  module.exports = fileList;

}).call(this);
